# -*- coding: utf-8 -*-
"""Lab3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lt7U-SNIIyUybE8q5NE6ULoPHo2KM8oD
"""

from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])

    while queue:
        node = queue.popleft()
        if node not in visited:
            print(node, end=" ")  # Process the node
            visited.add(node)
            queue.extend(graph[node])  # Add neighbors to the queue

# Example usage:
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F', 'G'],
    'D': ['B'],
    'E': ['B', 'H'],
    'F': ['C'],
    'G': ['C'],
    'H': ['E']
}

bfs(graph, 'A')  # Output: A B C D E F G H

"""#Activity 1

# Activity 1-b
"""

def BFS():
    initialState = 'D'
    goalState = 'F'

    graph = {
        'A': Node('A', None, ['B', 'C', 'E'], None),
        'B': Node('B', None, ['A', 'D', 'E'], None),
        'C': Node('C', None, ['A', 'F', 'G'], None),
        'D': Node('D', None, ['B', 'E'], None),
        'E': Node('E', None, ['A', 'B', 'D'], None),
        'F': Node('F', None, ['C'], None),
        'G': Node('G', None, ['C'], None)
    }

    frontier = [initialState]
    explored = []

    while len(frontier) != 0:
        currentNode = frontier.pop(0)
        explored.append(currentNode)

        for child in graph[currentNode].actions:
            if child not in frontier and child not in explored:
                graph[child].parent = currentNode
                if graph[child].state == goalState:
                    return actionSequence(graph, initialState, goalState)
                frontier.append(child)


def actionSequence(graph, initialState, goalState):
    solution = [goalState]
    currentParent = graph[goalState].parent

    while currentParent is not None:
        solution.append(currentParent)
        currentParent = graph[currentParent].parent

    solution.reverse()
    return solution


solution = BFS()
print(solution)

"""Activity 1-a

"""

from collections import deque

# Define the Node class
class Node:
    state = None  # Class variable shared by all instances

    def _init_(self, state, parent=None, actions=None, totalCost=0):
        self.state = state  # Unique to each node
        self.parent = parent
        self.actions = actions if actions else []  # List of child nodes
        self.totalCost = totalCost  # Path cost from the start node

# Define the graph as a dictionary of Node objects
graph = {
    'A': Node('A', None, ['B', 'C', 'E'], 0),
    'B': Node('B', None, ['A', 'D', 'E'], 0),
    'C': Node('C', None, ['A', 'F', 'G'], 0),
    'D': Node('D', None, ['B'], 0),
    'E': Node('E', None, ['A', 'B'], 0),
    'F': Node('F', None, ['C'], 0),
    'G': Node('G', None, ['C'], 0)
}

# Breadth-First Search (BFS) Algorithm
def bfs(start, goal):
    visited = set()  # Set to track visited nodes
    queue = deque([start])  # Initialize queue with start node

    while queue:
        current = queue.popleft()  # Dequeue the first node

        if current in visited:
            continue  # Skip already visited nodes

        print(f"Visiting: {current}")  # Print the visited node
        visited.add(current)

        if current == goal:  # If goal node is found, stop
            print(f"Goal '{goal}' found!")
            return

        # Enqueue all unvisited neighbors
        for neighbor in graph[current].actions:
            if neighbor not in visited:
                queue.append(neighbor)

# Run BFS from 'A' to find 'G'
print("BFS Traversal:")
bfs('A', 'G')

"""#Lab task 01

"""

from collections import deque

graph = {
    'Arad': ['Zerind', 'Sibiu', 'Timisoara'],
    'Zerind': ['Arad', 'Oradea'],
    'Oradea': ['Zerind', 'Sibiu'],
    'Sibiu': ['Arad', 'Oradea', 'Fagaras', 'Rimnicu Vilcea'],
    'Fagaras': ['Sibiu', 'Bucharest'],
    'Rimnicu Vilcea': ['Sibiu', 'Pitesti', 'Craiova'],
    'Timisoara': ['Arad', 'Lugoj'],
    'Lugoj': ['Timisoara', 'Mehadia'],
    'Mehadia': ['Lugoj', 'Drobeta'],
    'Drobeta': ['Mehadia', 'Craiova'],
    'Craiova': ['Drobeta', 'Rimnicu Vilcea', 'Pitesti'],
    'Pitesti': ['Rimnicu Vilcea', 'Craiova', 'Bucharest'],
    'Bucharest': ['Fagaras', 'Pitesti', 'Urziceni', 'Giurgiu'],
    'Giurgiu': ['Bucharest'],
    'Urziceni': ['Bucharest', 'Vaslui', 'Hirsova'],
    'Vaslui': ['Iasi', 'Urziceni'],
    'Iasi': ['Neamt', 'Vaslui'],
    'Neamt': ['Iasi'],
    'Hirsova': ['Urziceni', 'Eforie'],
    'Eforie': ['Hirsova']
}

def bfs(start, goal):
    queue = deque([[start]])
    visited = set()

    while queue:
        path = queue.popleft()
        node = path[-1]

        if node == goal:
            return path

        if node not in visited:
            visited.add(node)
            for neighbor in graph.get(node, []):
                new_path = list(path)
                new_path.append(neighbor)
                queue.append(new_path)

print(bfs('Arad', 'Bucharest'))

"""#Lab task 02

"""

from collections import deque


maze = [
    [1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 0, 0, 0, 1],
    [1, 0, 1, 1, 1, 0, 1],
    [1, 0, 1, 0, 1, 0, 1],
    [1, 0, 1, 0, 0, 0, 1],
    [1, 0, 0, 0, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 1]
]


start = (5, 1)
goal = (1, 5)


directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

def bfs(maze, start, goal):
    queue = deque([(start, [start])])
    visited = set([start])

    while queue:
        (row, col), path = queue.popleft()


        if (row, col) == goal:
            return path


        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc

            if (0 <= new_row < len(maze) and 0 <= new_col < len(maze[0]) and
                maze[new_row][new_col] == 0 and (new_row, new_col) not in visited):

                queue.append(((new_row, new_col), path + [(new_row, new_col)]))
                visited.add((new_row, new_col))

    return None


path = bfs(maze, start, goal)
if path:
    print("Shortest Path:", path)
else:
    print("No path found.")

"""# Network x graph visualization for bfs

"""

import networkx as nx
import matplotlib.pyplot as plt
from collections import deque

def bfs_visualize(graph, start):
    visited = set()
    queue = deque([start])
    bfs_edges = []

    while queue:
        node = queue.popleft()
        if node not in visited:
            visited.add(node)
            for neighbor in graph.neighbors(node):
                if neighbor not in visited:
                    queue.append(neighbor)
                    bfs_edges.append((node, neighbor))  # Store edges for visualization

    return bfs_edges

# Create a graph
G = nx.Graph()
edges = [
    ('A', 'B'), ('A', 'C'), ('B', 'D'), ('B', 'E'),
    ('C', 'F'), ('C', 'G'), ('E', 'H')
]
G.add_edges_from(edges)

# Perform BFS and get edges
start_node = 'A'
bfs_edges = bfs_visualize(G, start_node)

# Draw the graph
pos = nx.spring_layout(G)  # Layout for visualization
plt.figure(figsize=(8, 6))

# Draw all nodes and edges
nx.draw(G, pos, with_labels=True, node_color='lightblue', edge_color='gray', node_size=2000, font_size=12, font_weight='bold')

# Highlight BFS traversal edges
nx.draw_networkx_edges(G, pos, edgelist=bfs_edges, edge_color='red', width=2)

plt.title("BFS Visualization using NetworkX")
plt.show()

"""# BFS algorithm to find shortest path using network x

"""

import networkx as nx
import matplotlib.pyplot as plt
from collections import deque

def bfs_path(graph, start, goal):
    queue = deque([[start]])  # Queue stores paths
    visited = set()

    while queue:
        path = queue.popleft()  # Get the first path from the queue
        node = path[-1]  # Last node in the current path

        if node == goal:
            return path  # Return the path if the goal is reached

        if node not in visited:
            visited.add(node)
            for neighbor in graph.neighbors(node):
                new_path = path + [neighbor]  # Create a new path
                queue.append(new_path)

    return None  # Return None if no path is found

# Create a graph
G = nx.Graph()
edges = [
    ('A', 'B'), ('A', 'C'), ('B', 'D'), ('B', 'E'),
    ('C', 'F'), ('C', 'G'), ('E', 'H')
]
G.add_edges_from(edges)

# Find BFS path
start_node = 'A'
goal_node = 'H'
path = bfs_path(G, start_node, goal_node)

# Draw the graph
pos = nx.spring_layout(G)  # Layout for better visualization
plt.figure(figsize=(8, 6))

# Draw all nodes and edges
nx.draw(G, pos, with_labels=True, node_color='lightblue', edge_color='gray', node_size=2000, font_size=12, font_weight='bold')

# Highlight BFS path in red
if path:
    path_edges = list(zip(path, path[1:]))  # Convert path nodes into edges
    nx.draw_networkx_edges(G, pos, edgelist=path_edges, edge_color='red', width=2)

plt.title(f"BFS Shortest Path from {start_node} to {goal_node}")
plt.show()